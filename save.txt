#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <SDL2/SDL.h>
#include "signals.h"

typedef struct
{
    uint64_t *samples_played;
    float freq;
    double actual_time;
} ud;

typedef struct 
{
    double attack_to_decay_time;
    double decay_to_sustain_time;
    double release_time;
    
    double start_amplitude;
    double attack_top_amplitude;
    double sustain_amplitude;
    double release_amplitude;
    
    bool released;

    double press_time;
    double stop_time;
} ADSR;

ADSR *init_ADSR_envelope(double attack_to_decay_time,
    double decay_to_sustain_time,
    double release_time,
    double start_amplitude,
    double attack_top_amplitude,
    double sustain_amplitude,
    double release_amplitude)
{
    ADSR *adsr = malloc(sizeof(ADSR));

    adsr->attack_to_decay_time = attack_to_decay_time;
    adsr->decay_to_sustain_time = decay_to_sustain_time;
    adsr->release_time = release_time;

    adsr->start_amplitude = start_amplitude;
    adsr->sustain_amplitude = sustain_amplitude;
    adsr->release_amplitude = release_amplitude;
    
    adsr->released = false;

    adsr->press_time = 0;
    adsr->stop_time = 0;
}



float adsr_get_amplitude(double time, ADSR * envelope)
{
    float signal;
    //The time from the press of the signal
    double actual_signal_time = time - envelope->press_time;
    //If the time from the press of the signal is still in the AD phase than calculate the amplitude
    if(actual_signal_time <= envelope->attack_to_decay_time+envelope->decay_to_sustain_time)
    {
        //AD

        //if in the Attack phase
        if(actual_signal_time <= envelope->attack_to_decay_time)
        {
            //Normalise the constant between 1 and 0 and multiply by attack_top_amplitude
            //Makes an affine function from start amplitude to attack_top_amplitude
            signal = (envelope->attack_top_amplitude - envelope->start_amplitude) * (actual_signal_time/envelope->attack_to_decay_time) + envelope->start_amplitude;
        }
        //if in the Decay phase
        else
        {
            //normalise the constant between 1 and 0 and multiply by sustain_amplitude
            //since we have reached atta_to_amplitude we will now subtract from it
            //we need to get to the sustain_amplitude at the end so we will be
            //normalising (attack_top_amplitude - sustain_amplitude)
            //
            signal = envelope->attack_top_amplitude - 
            ((envelope->attack_top_amplitude - envelope->sustain_amplitude) * 
            (actual_signal_time/(envelope->attack_to_decay_time + envelope->decay_to_sustain_time)));
        }
    }
    else
    {
        //SR

        //Release
        if(envelope->released)
        {
            //If the time the signal is played is still in the ADSR enveloppe,
            //process the amplitude, if not send out zero
            if(actual_signal_time < envelope->stop_time + envelope->release_time)
            {
                signal = envelope->sustain_amplitude - 
                ((envelope->sustain_amplitude - envelope->release_amplitude) * 
                (actual_signal_time/(envelope->stop_time + envelope->release_time)));
            }
            else
            {
                //End the envelope sequence
                signal = 0;
            }
        }
        //Sustain
        else
        {
            signal = envelope->sustain_amplitude;
        }
    }
    return signal;
}

void audio_callback(void *userdata, uint8_t *stream, int len)
{
    ud *us_d = (ud *)userdata;
    uint64_t *samples_played = (uint64_t *)(us_d->samples_played);
    float *fstream = (float *)(stream);
    float frequency = us_d->freq;
    static const float volume = 1;
    for (int sid = 0; sid < (len / 8); ++sid)
    {
        double time = (*samples_played + sid) / 44100.0;
        float val = sine(volume,frequency,time);
        fstream[2 * sid + 0] = val; /* L */
        fstream[2 * sid + 1] = val; /* R */
    }
    *samples_played += (len / 8);
}



int main(int argc, char *argv[])
{
    ADSR *env = init_ADSR_envelope(0.3,0.15,0.2,0.1,1.0,0.6,0.3);
    uint64_t samples_played = 0;
    ud data;
    data.samples_played = &samples_played;
    
    if (SDL_Init(SDL_INIT_AUDIO) < 0)
    {
        fprintf(stderr, "Error initializing SDL. SDL_Error: %s\n", SDL_GetError());
        return -1;
    }

    SDL_AudioSpec audio_spec_want, audio_spec;
    SDL_memset(&audio_spec_want, 0, sizeof(audio_spec_want));

    audio_spec_want.freq = 44100;
    audio_spec_want.format = AUDIO_F32;
    audio_spec_want.channels = 2;
    audio_spec_want.samples = 1024;
    audio_spec_want.callback = audio_callback;
    audio_spec_want.userdata = &data;

    SDL_AudioDeviceID audio_device_id = SDL_OpenAudioDevice(
        NULL, 0,
        &audio_spec_want, &audio_spec,
        SDL_AUDIO_ALLOW_FORMAT_CHANGE);

    if (!audio_device_id)
    {
        fprintf(stderr, "Error creating SDL audio device. SDL_Error: %s\n", SDL_GetError());
        SDL_Quit();
        return -1;
    }

    int window_width = 600;
    int window_height = 600;
    SDL_Window *window;
    {
        window = SDL_CreateWindow(
            "SDL Tone Generator",
            SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
            window_width, window_height,
            SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);

        if (!window)
        {
            fprintf(stderr, "Error creating SDL window. SDL_Error: %s\n", SDL_GetError());
            SDL_Quit();
            return -1;
        }
    }

    SDL_PauseAudioDevice(audio_device_id, 1);

    SDL_Event event;

    bool running = true;
    while (running)
    {
        while (SDL_PollEvent(&event))
        {
            switch (event.type)
            {
            case SDL_KEYDOWN:
                const char *c = SDL_GetKeyName(event.key.keysym.sym);
                float freq = note_to_freq(c[0] + 32);
                data.freq = freq;
                SDL_PauseAudioDevice(audio_device_id, 0);
                break;
            case SDL_KEYUP:
                SDL_PauseAudioDevice(audio_device_id, 1);
                break;
            case SDL_QUIT:
                SDL_PauseAudioDevice(audio_device_id, 1);
                running = false;
                break;

            default:
                break;
            }
        }
    }

    SDL_DestroyWindow(window);
    SDL_CloseAudioDevice(audio_device_id);
    SDL_Quit();

    return 0;
}